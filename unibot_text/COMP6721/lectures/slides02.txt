
all the distances by which
Slide 75
 the best result is then chosen.
 memory requirements high -- exponential space for states
Slide 72
71
Slide 2
 24-puzzle  -->  25! ~ 1025 states
Motivation
LeftUpRight
3. Goal test function
80
57
Algorithm A
Slide 40
Best-First Search: Example
ter
Perception
61
hill-climbing will stop,
 Most of the time, it is not feasible to do an exhaustive search,
 Open is a priority queue sorted using the depth of the nodes from
 A technique that improves the efficiency of search,
 Depth-limited Search
 The order of the nodes in the open list depends on the search
 h3(n) = sum of permutation inversions
 The time spent computing heuristics must be recovered
1 2 3
85
 In all search strategies, you need:
1. open = [A-null-5]  closed = []
 Heuristic search:
 h3(n) = n5 + n8 + n4 + n2 + n1 + n7 + n3 + n6
35
Lower h(n) is better
 Many AI problems, can be expressed in terms of going
8 STATE REPRESENTATION
 guarantees to find the lowest cost solution path to the
86
 stores all the nodes that have already been visited (to avoid cycles).
money to the first person who would solve the
= 16
 Summary
Open = [F, G, H, I, J, K, L]
 However, you need to consider the computational cost of
 Steepest ascent hill climbing:
 Heuristic evaluation functions are highly
Slide 67
Slide 55
 random initial states are generated
 algorithm A used with such an h(n) is called “algorithm A*”
possibly sacrificing on completeness
 Solution:
→ Worksheet #1 (“Algorithm A”)
 Breadth-first:
76
higher h(n) than the
Goal test function:
 visit successors before siblings
 A*
18
Uniform Cost Search
 f*(n) actual cost of lowest cost of the solution
15
 Uninformed search
9
23
 Often, there is no direct way to find a solution to a
 Best-first search:
 Does not maintain a list of next nodes to visit (an open list)
Generic Search Algorithm
along a suboptimal path
Som
 State Space Representation
But no one ever won the prize…
State Space as a Search Tree
Slide 71
 Modified evaluation function f:
60
if (HEURISTIC-VALUE(c) < nextEval) // lower h is better
Slide 43
Slide 17
5 6 7 8
 reached a local maximum, not the global maximum
termination
 f(n) estimate of the lowest cost of the solution
25
Knowledge
 Repeats depth first search with gradually increasing
41
 Breadth-first
Slide 48
Slide 63
 closed list (aka the explored set)
 guarantees to find the lowest cost solution path to the goal (if it
pickup&putOnTable(A)
31
 Similar to climbing a mountain in the fog with amnesia …
blank moves up, blank moves down, blank moves left, blank moves right
 DFS and BFS differ only in the way they order nodes in the
 At 100 millions states/sec:
Today
 Uniform Cost
Invented in 1874 by Noyes Palmer Chapman
 To trace back the entire path of the solution after
7
 h1(n)  = misplaced numbered tiles
h3(N) = sum of permutation inversions
 Manhattan distance: sum up
some function
 +1pt if a block is NOT sitting where it is supposed to sit
= 13
 1026 = nb of nanoseconds since the “big bang”
 If you have a good h(n), best-first can find the
Slide 12
 Blind search without cycle check may never
the search, each node in the lists contain:
75
L = CHILDREN(currentNode);
(n2-1)-puzzle?
 ex. solved puzzle, being at Concordia
Heuristic - Heureka!
Slide 10
= 4  + 6  + 3   + 1   + 0  + 2   + 0  + 0
Slide 20
Slide 13
the cost from the root to node n –
 so need an informed/heuristic search
54
Designing Heuristics
 Hill Climbing
2. Heuristic search:
37
1. Initial State
Depth-Limited Search
Example: Hill Climbing with Blocks World
 but we can list the possibilities and search through them
Snapshot of BFS
Slide 34
Slide 50
Slide 42
Slide 15
1
Slide 31
 We try to choose smartly
 Insert nodes in open list so that the nodes are sorted in
 …
 Breadth-first:
Depth-first No Stack
Slide 1
each movement costs 1
 Operators:
Slide 23
 Hill climbing
 use depth-first search, but
 h2(n) = 2+3+0+1+3+0+3+1
  h1(n) = Hamming distance = number of misplaced tiles = 6
 Depth-limited search
connects a node s
Slide 16
 Depth-first
c) If s is a goal state, exit  with success.  Extract the solution path
Assume U is goal state
Slide 6
h(n) = 2
P-0
Goal state
Breadth-first No Queue
Slide 29
5 6
 Heuristics might be wrong:
connected component
 Determine order for examining states
 then h2 is more informed than h1
Algorithm A*
4. → Worksheet #1 (“Best-First Search”)
 works well on a "shoulder"
language
 nodes are added on the top of the list.
 Hill climbing
Slide 69
70
Slide 45
me
 use "open" as a priority queue
26
 h(n) estimate of cost to reach goal from node n
so the path cost is the length of the path (the number of moves)
Example: 8-Puzzle – Heuristic 2
2. Monotonicity:
Informedness
 starting state
current one, select it.
following problem:
 For two admissible heuristics h1 and h2
Path cost function:
Slide 57
 In general: the more informed a heuristic is,
and closed are
Slide 30
ara
a) If the open list  is empty, then exit with failure.
 guarantees to find the lowest cost path to each state n
→ Worksheet #1 (“Depth-First Search”)
72
74
Depth-First Search Example
 Iterative deepening search
 Search algorithm:  how the search space is visited
...
pickup&stack(A,H) pickup&putOnTable(H)
 i.e. it guarantees to find the lowest cost solution path
69
 Now consider f*(n) = g*(n) + h*(n):
Slide 62
 Best-First
46
Down
--> admissible
Slide 25
42
shorter/least expensive paths
 f(n) estimate of total cost along path through n
2. Set of operators
 An arc (or edge)
Slide 36
highlighted
 Heuristic:
on a plateau
(n2-1)-puzzle
source: adapted from G. Luger (2005)
16
Slide 51
but there is a good chance of finding it quickly
 h2: Better heuristic
g(n), h(n) and f(n)
Uniform Cost No Priority queue sorted by g(n)
1. Initialize the open list  with the initial node so (top node)
 aka: systematic/exhaustive/blind/brute force search
solution path
82
8
 keep going even if the best successor has the same value as
distance tiles have to be
 Depth-first:
 choose "best" next node to expand
State Graph
 does not consider the
 Uniform Cost Search
  h2(n) = Manhattan distance = 13
source: Russel & Norvig (2003)
4. open = [K-E L-E F-B C-A D-A]  closed = [E B A]
 Iterative Deepening
Natural
always go higher than where you are now,
 e.g.: breadth-first is admissible  -- it uses f(n) = g(n) + 0
 pick the best position out of all the next possible moves
?
87
COMP 6721: State Space Search
 but has no guarantee to be correct whatsoever!
 Ex: to solve a puzzle, to drive from home to Concordia…
 ex:
nextNode = NULL;
 Always choose the next node to visit to be the one with the
1. Brute force search:
admissible
 actions responsible for transition between states
Compromise for DFS :
= n5 + n8 + n4  + n2 + n1 + n7 + n3 + n6
is better than the current one
= 4  + 6  + 3   + 1   + 0  + 2  + 0  + 0  = 16
a lower h(n) is better…
 Not optimal (no guarantee to find the shortest path)
Manhattan distance
t n
3. Informedness:
 generate and search all possibilities (but inefficient)
cost solution path
Slide 73
2 1
satisfaction
 See next slide…
 Breadth First Search
depth-first
 guarantees to find the shortest solution path
1. open = [A-null]  closed = []
5Path-Cost
parent… --> local minimum
- no constraints on h(n)
later called g(n)
20
 DFS: (open is a stack)
 an A* algorithm is admissible
n goal
DFS and BFS
Slide 22
 Assigns a cost to a path to tell if a path is preferable to
17
1. Admissibility:
 State Space Search
 Heuristic:
should be on its left in the goal state.
exists)
 h(n) = estimate of the lowest cost from n to goal
34
pre
Slide 44
 ex: TSP: "nearest neighbour" heuristic
2
 h(goal) = 0
Informed Search (aka heuristic search)
 In graph representation, cycles can prevent
Slide 80
 Failure (no solution)
5
to a node s’ if
Slide 7
they are not already in the closed and/or open lists (to avoid
 Problem is represented by:
State: Any arrangement of 8 numbered tiles and an empty tile on a 3x3 board
Slide 88
Slide 49
 Requires less memory
 But: heuristic might fail
depth limits
12
node n
cost of reaching the goal
Uninformed VS Informed Search
Hill Climbing
48
Slide 53
e o
19
 only try the possibilities that you think (based on your
78
 as soon as you find a position that is better than the
when compared with goal
2. open = [B-A  C-A  D-A]  closed [A]
score a node in the search tree
 measure for the “quality” of a heuristic
4 6
= 6
 a state that is better than all its neighbors but is not better
 h is monotonic if for every node n and every successor n’ of n:
  DFS uses a stack:
r p
27
Slide 85
 Breadth-first and Depth-first
Slide 79
8-puzzle
Search Uses h(n)? Open is a…
cycles)
 But what if all edges/moves do not have the same cost?
49
Slide 4
 g(n) actual cost of path from start to node n
 h1(n) ≤ h2(n) ≤ h*(n)
 Search graph at
29
Slide 59
 the more informed, the better
pickup&stack(H,A)
Slide 24
Slide 74
there are several standard goals states for the 8-puzzle
 Idea:
 15-puzzle --> ~ 55 hours
help!
Iterative Deepening No Stack
Heuristics for the 8-Puzzle
 will eventually try all possible paths
 It is an exhaustive search …
7 8
3 4
Just to make sure we’re clear…
24
Slide 39
Example: The 8-puzzle
Slide 19
Breadth-First Search Example
Data Structures
47
BFS vs.
 so search could continue down a wrong path
Rubik’s cube Tetris
Function Depth-First Search
ascending  h(n)
(tiles out of place)
PARENT-NODE
  Many slides from:
 Note:  does not guarantee to find the lowest cost search
space and the depth of the solution is unknown
from the initial state to the goal
33
b) Else, take the first node s  from the open list.
 “local admissibility”
Slide 37
problem
each state the 1st time it is encountered !
Problems with Hill Climbing
 Foothills (or local maxima)
nextEval = HEURISTIC-VALUE(c);
 h3: Even Better
 ie. visit level-by-level
 States on open
 best-first used with such a g(n) is called “algorithm A”
Constraint
// Return current node since no better child state exists
from s to so
Heuristic search
Algorithm A on the 8-puzzle
2. open = [B-A-4  C-A-4  D-A-6]  (arbitrary choice) closed [A]
 Do depth-first but with depth cutoff k (depth
Initial state
36
 Use a tree representation, and check for cycles
number of tiles out of place
tiles are out of place
63
Best-First: Example
 A*
38
 Heuristic function h(n) = an approximation of the
 A heuristic is monotonic if it always finds the optimal path to
rep.Planning
Slide 8
source: G. Luger (2005)
 Preferred search method when there is a large search
 Nb of states:
 Focus on paths that seem most promising according to
 problem with hill-climbing:
the better the search performance
Monotonicity (aka consistent)
Set of operators:
Initial state Goal state
Slide 58
moved
 nodes are added at the end of the list.
 h*(n) actual lowest cost from n to goal
Slide 66
 Best-First
 Depth-first:
14
 g*(n) cost of lowest cost path from start to
Slide 65
nextEval = INFINITY;
44
Compromise between BFS and DFS:
5Depth
Slide 27
 Breath-first and Depth-first
path (from start to goal passing through n)
 order of nodes controls order of search
 a flat area of the search space in which the next states
Artificial Intelligence:
51
3. open = [C-A-4 E-B-5 F-B-5  D-A-6]  closed = [B A]
CHILDREN
Don’t be confused…
 h1(n)  = 6
by a better search
 Maintain depth/cost count, i.e., give preference to
Yes Priority queue sorted by f(n)
83
Slide 18
Hill Climbing Yes none
Slide 78
 guarantees to find the lowest cost path to each state n encountered
5. open = [S-K L-E F-B C-A D-A]  closed = [K E B A]
Depth-first vs. Breadth-first
evaluating the heuristic…
 at a local maximum, all moves appear to make things worse.
Snapshot of DFS
for all c in L
Slide 38
than some other states farther away.
contain more than one
Slide 76
because all children have
79
 if g(n) ≥ g*(n) for all n
- same as A, but h(n) must be
h(n)
 ex: 8-puzzle: we may need to move tiles temporarily out of goal
 Applied to a state to determine if it is a goal state
Breadth-first vs Depth-first Search
Slide 84
 An admissible heuristics may temporarily reach non-goal states
Slide 14
 if h1(n) ≤ h2(n), for all states n
Adapted from https://en.wikipedia.org/wiki/Hill_climbing
66
 i.e. h(n) never overestimates the true cost from n to a goal
Systems
45
dependent on the search domain
 So how do we design a “good” heuristic?
53
 Uniform-cost
but never go back…
52
re
 “optimistic”
58
from an initial state to a goal state
Search tree
15-puzzle
d) Else, insert s in the closed list (s has been visited /expanded)
in the search
inversions
40
 Finds the shortest path (limited depth)
Slide 61
Some parameter to represent n
Slide 60
the root
 it is not possible to determine the best direction in which
represented by a
Depth = length of path from root to node
...and so on until either U is found or open = []
 Need an evaluation function (heuristic function) to
4. → Worksheet #1 (“Breadth-First Search”)
 open list (aka the frontier)
because search space is too large!
 The state graph may
5 8 4 2 1 7 3 6
4 5 6
 8-puzzle --> 0.036 sec
STATE n
8 1 2 3
Slide 35
3. open = [C-A D-A  E-B F-B]  closed = [B A]
Slide 83
current best guess) are more likely to lead to good solutions
Iterative Deepening
 Optimal: will always finds shortest path
Slide 3
State Space for the 8-puzzle
nextNode = c;
 never overestimates the actual cost of reaching the goal
13
65
Slide 11
 solution to hill-climbing:
 15-puzzle  -->  16! ~ 2.09 x 1013 states
 General hill climbing strategy:
 Hamming distance : count
 Plateau
 Cutoff (no solution within cutoff)
 We systematically explore the alternatives
http://robotics.stanford.edu/~latombe/cs121/winter02/home.htm
g(n)
RightAction
 visit siblings before successors
 if h(n) ≤ h*(n) for all n
Example: 8-Puzzle – Heuristic 1
Search is about the exploration of alternatives
88
 a rule of thumb, a good bet
 8-puzzle  -->  9! = 362,880 states
Sam Loyd even offered $1,000 of his own
8-Puzzle: Successor Function
 i.e. f(n) is non-decreasing along any path
 Bad heuristics lead to frequent backtracking
 (Designing Heuristics)
 run each until it halts or makes no significant progress.
 A heuristic is admissible if it never overestimates the
 instead of moving to the first position that
currentNode = startNode;
 Random-restart hill-climbing
 Requires little memory (fundamentally, it’s a depth first)
Slide 5
More informed heuristics search smaller space to find the
 24-puzzle  -->  > 109 years
h(n)
 0pt if a block is sitting where it is supposed to sit
22
 inefficient if branching factor B is very high
have the same value.
Steepest Ascent Hill Climbing
77
Slide 52
if nextEval >= HEURISTIC-VALUE(currentNode)
Slide 46
How large is the state space of the
State Space Search
 Bidirectional search
Learning
lowest cost from node n to the goal
 For each numbered tile, count how many tiles on its right
2. Initialize the closed list   to  empty
search)
 Uninformed search
goal (if it exists)
Slide 86
 Search space: the set of all states that can be reached
 BFS: (open is a queue)
 according to a selection function (i.e. a heuristic function h(n))
 g(n) = cost of current path from start to node n
source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.
Slide 54
 The first solution may not be the best,
BOOKKEEPING
strategy
3. open = [E-B F-B C-A D-A]  closed = [B A]
55
11
 this is called best-first search
Depth-limited No Stack
Google itinerary
source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991. & Russel & Norvig (2003)
Slide 56
path.
....
… but Sam Loyd claimed he invented it!

encountered in the search
Admissibility
Slide 87
Robotics
68
to move by making local comparisons.
Reasoning
56
the
4321
50
- guarantees to find the lowest
from the initial state by any sequence of action
 1075 = nb of molecules in the universe
 lists generated nodes not yet expanded
current node
Evaluating Heuristics
h(n) = 2h(n) = 2h(n) = 2
currentNode = nextNode;
robotics.stanford.edu/~latombe/cs121/2003/home.htm
39
 Informed search (heuristic search)
iteration 6 of
Slide 82
Search
Best-First Yes Priority queue sorted by h(n)
 g(n) current cost from start to node n
Notes on Best-first
30
 so lower h(n) is better
Slide 47
open list:
Iterative Deepening: Example
distinct node
solution very quickly
f(n) = g(n) + h(n)
loop do
…
59
 e.g. state space of all possible moves in chess = 10120
 guarantees to find the lowest cost
 h1: Simplest heuristic
State Space
But:
Best-First Search
62
Some Solutions to Hill-Climbing
Slide 26
Slide 41
Summary
4
Slide 77
4. Path cost function
terminate
 i.e.:
Slide 33
search space is too large
 Evaluation function f(n) = g(n) + h(n) for node n:
Slide 21
 Each state is
 h(n) ≤ h*(n)  for all n
Slide 9
breadth-first
Slide 68
 Intuition: number of misplaced tiles is less informed than
e) Insert the successors of s  in  the  open list  in a certain order if
return currentNode;
to
Algorithm A vs Algorithm A*
10
Slide 70
  BFS uses a queue:
 one move is selected and all others are forgotten.
73
 h(n) estimate of the lowest cost from n to goal
Agent
15-Puzzle
position in order to place another tile in goal position
Notes:
sen
 but could lead to infinite loop
 ex. unsolved puzzle, being at home
 h2(n)  =  Manhattan distance
best h(n) -- regardless of where it is in the search space
Closed = [A, B, C, D, E]
 Three possible outcomes:
 Solution
Example: 8-Puzzle – Heuristic 3
source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.
required: Bn
 But both search are impractical in real applications
 h(initial) = 2
Breadth-First Search
another
Example: 8-Puzzle
 uses a priority queue sorted using
at which nodes are not expanded)
21
 so far, all search algorithms have been uninformed (general
search
 Informed search
state matches the goal state
h(n) = 1
64
3
s’  ∈ SUCCESSOR(s)
43
3. Repeat
67
6
 pickup&putOnTable(Block)
 with a maximum depth before going to next level
= 2 + 3 + 0 + 1 + 3 + 0 + 3 + 1 = 13
... Expert
 pickup&stack(Block1,Block2)
 h(n) ≤ c(n,n') + h(n')
 sum of permutation
