
State Space as a Search Tree
 +1pt if a block is NOT sitting where it is supposed to sit
… but Sam Loyd claimed he invented it!
BFS vs.
Slide 74
Path cost function:
 Search space: the set of all states that can be reached
15
Slide 35
the cost from the root to node n –
help!
Slide 72
 Depth-first
Search is about the exploration of alternatives
 Search algorithm:  how the search space is visited
by a better search
nextNode = NULL;
6
80
ara
Slide 29
 algorithm A used with such an h(n) is called “algorithm A*”
 Heuristic:
Notes:
 Best-First
 Hill Climbing
depth limits
 instead of moving to the first position that
Breadth-First Search
17
2. open = [B-A  C-A  D-A]  closed [A]
Slide 30
search)
 The state graph may
path.
 The order of the nodes in the open list depends on the search
pre
possibly sacrificing on completeness
51
 pick the best position out of all the next possible moves
More informed heuristics search smaller space to find the
 To trace back the entire path of the solution after
to
current best guess) are more likely to lead to good solutions
8 STATE REPRESENTATION
64
because search space is too large!
 Solution
 Idea:
 guarantees to find the shortest solution path
1. Initialize the open list  with the initial node so (top node)
 h(n) ≤ h*(n)  for all n
breadth-first
 h1(n) ≤ h2(n) ≤ h*(n)
if (HEURISTIC-VALUE(c) < nextEval) // lower h is better
Depth-limited No Stack
 Use a tree representation, and check for cycles
Best-First Yes Priority queue sorted by h(n)
Slide 53
Slide 4
67
at which nodes are not expanded)
 guarantees to find the lowest cost
Slide 62
 Manhattan distance: sum up
Slide 31
13
along a suboptimal path
Hill Climbing
 ie. visit level-by-level
 a flat area of the search space in which the next states
82
Slide 57
 it is not possible to determine the best direction in which
from an initial state to a goal state
 order of nodes controls order of search
 h(n) = estimate of the lowest cost from n to goal
...and so on until either U is found or open = []
48
source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.
 does not consider the
 The first solution may not be the best,
87
 an A* algorithm is admissible
Perception
Agent
5 6 7 8
 a state that is better than all its neighbors but is not better
 Breadth-first and Depth-first
blank moves up, blank moves down, blank moves left, blank moves right
 1026 = nb of nanoseconds since the “big bang”
Don’t be confused…
 use "open" as a priority queue
 Often, there is no direct way to find a solution to a
 A*
Slide 46
 Breadth-first:
Slide 86
39
Example: Hill Climbing with Blocks World
56
Slide 12
 i.e. f(n) is non-decreasing along any path
problem
37
 according to a selection function (i.e. a heuristic function h(n))
= 2 + 3 + 0 + 1 + 3 + 0 + 3 + 1 = 13
solution very quickly
 so need an informed/heuristic search
 Heuristic search:
 g(n) actual cost of path from start to node n
and closed are
pickup&stack(H,A)
Rubik’s cube Tetris
parent… --> local minimum
Slide 51
admissible
Down
19
 Do depth-first but with depth cutoff k (depth
 Similar to climbing a mountain in the fog with amnesia …
Learning
e o
4
 (Designing Heuristics)
distance tiles have to be
 g*(n) cost of lowest cost path from start to
75
Slide 37
Slide 77
 Breath-first and Depth-first
Algorithm A*
40
Slide 16
22
if nextEval >= HEURISTIC-VALUE(currentNode)
 Depth-limited search
Slide 25
Slide 88
 “optimistic”
Function Depth-First Search
Hill Climbing Yes none
 visit siblings before successors
space and the depth of the solution is unknown
c) If s is a goal state, exit  with success.  Extract the solution path
2. Monotonicity:
12
 h is monotonic if for every node n and every successor n’ of n:
Set of operators:
h(n) = 2
Slide 83
 inefficient if branching factor B is very high
CHILDREN
 solution to hill-climbing:
 e.g.: breadth-first is admissible  -- it uses f(n) = g(n) + 0
Slide 10
 0pt if a block is sitting where it is supposed to sit
Invented in 1874 by Noyes Palmer Chapman
  BFS uses a queue:
2. Initialize the closed list   to  empty
each state the 1st time it is encountered !
Goal test function:
8-puzzle
 Blind search without cycle check may never
higher h(n) than the
86
?
3. Goal test function
 At 100 millions states/sec:
Iterative Deepening
Slide 17
Uniform Cost Search
another
Heuristic search
Slide 56
 at a local maximum, all moves appear to make things worse.
Evaluating Heuristics
 f*(n) actual cost of lowest cost of the solution
h(n)
path (from start to goal passing through n)
Slide 78
Slide 65
Slide 43
lowest cost from node n to the goal
 15-puzzle  -->  16! ~ 2.09 x 1013 states
Informed Search (aka heuristic search)
 Informed search (heuristic search)
42
nextEval = HEURISTIC-VALUE(c);
5 8 4 2 1 7 3 6
Slide 87
iteration 6 of
always go higher than where you are now,
2. Set of operators
h(n) = 2h(n) = 2h(n) = 2
contain more than one
 f(n) estimate of the lowest cost of the solution
 Applied to a state to determine if it is a goal state
 But what if all edges/moves do not have the same cost?
shorter/least expensive paths
 stores all the nodes that have already been visited (to avoid cycles).
 closed list (aka the explored set)
Slide 27
Slide 9
 Uninformed search
h3(N) = sum of permutation inversions
 Depth-first:
41
69
8-Puzzle: Successor Function
me
exists)
 Assigns a cost to a path to tell if a path is preferable to
2 1
 choose "best" next node to expand
Problems with Hill Climbing
2
55
 Bad heuristics lead to frequent backtracking
 DFS and BFS differ only in the way they order nodes in the
Summary
30
5. open = [S-K L-E F-B C-A D-A]  closed = [K E B A]
Algorithm A on the 8-puzzle
 Focus on paths that seem most promising according to
25
 DFS: (open is a stack)
distinct node
Slide 79
 Note:  does not guarantee to find the lowest cost search
 Hill climbing
21
How large is the state space of the
- same as A, but h(n) must be
Goal state
 We systematically explore the alternatives
Informedness
moved
Breadth-first No Queue
because all children have
 Plateau
61
 guarantees to find the lowest cost solution path to the goal (if it
State: Any arrangement of 8 numbered tiles and an empty tile on a 3x3 board
Robotics
26
 if g(n) ≥ g*(n) for all n
8 1 2 3
 State Space Search
 Best-First
Slide 24
Systems
 h2: Better heuristic
tiles are out of place
= 4  + 6  + 3   + 1   + 0  + 2   + 0  + 0
Algorithm A vs Algorithm A*
Slide 7
 actions responsible for transition between states
4. → Worksheet #1 (“Best-First Search”)
1. Admissibility:
1
 lists generated nodes not yet expanded
 h(n) ≤ c(n,n') + h(n')
 so search could continue down a wrong path
  h2(n) = Manhattan distance = 13
4321
 run each until it halts or makes no significant progress.
following problem:
State Space for the 8-puzzle
Slide 40
Algorithm A
Constraint
sen
Slide 38
PARENT-NODE
But:
 pickup&stack(Block1,Block2)
Slide 21
Generic Search Algorithm
 if h(n) ≤ h*(n) for all n
solution path
Slide 39
Slide 61
 h(initial) = 2
for all c in L
 h2(n) = 2+3+0+1+3+0+3+1
...
(n2-1)-puzzle
18
45
 keep going even if the best successor has the same value as
 h2(n)  =  Manhattan distance
when compared with goal
Slide 66
36
to move by making local comparisons.
Lower h(n) is better
 Three possible outcomes:
e) Insert the successors of s  in  the  open list  in a certain order if
Slide 34
best h(n) -- regardless of where it is in the search space
1. Brute force search:
Reasoning
r p
71
Slide 75
Slide 19
1. open = [A-null]  closed = []
satisfaction
10
all the distances by which
RightAction
P-0
Sam Loyd even offered $1,000 of his own
Slide 15
Just to make sure we’re clear…
Some Solutions to Hill-Climbing
Slide 69
later called g(n)
…
Depth-First Search Example
 Repeats depth first search with gradually increasing
 Best-first search:
money to the first person who would solve the
7
 Hill climbing
// Return current node since no better child state exists
 Many AI problems, can be expressed in terms of going
15-Puzzle
Som
 In general: the more informed a heuristic is,
 memory requirements high -- exponential space for states
f(n) = g(n) + h(n)
language
1. Initial State
66
BOOKKEEPING
 aka: systematic/exhaustive/blind/brute force search
 Evaluation function f(n) = g(n) + h(n) for node n:
connected component
cost of reaching the goal
3. Informedness:
78
 Requires little memory (fundamentally, it’s a depth first)
 Heuristics might be wrong:
s’  ∈ SUCCESSOR(s)
 A technique that improves the efficiency of search,
Slide 54
Slide 36
Slide 33
7 8
 Ex: to solve a puzzle, to drive from home to Concordia…
cost solution path
2. open = [B-A-4  C-A-4  D-A-6]  (arbitrary choice) closed [A]
Slide 82
77
5
52
Slide 11
Slide 52
 random initial states are generated
required: Bn
(n2-1)-puzzle?
 h(n) estimate of cost to reach goal from node n
Slide 63
Heuristics for the 8-Puzzle
 Requires less memory
should be on its left in the goal state.
 as soon as you find a position that is better than the
 then h2 is more informed than h1
 24-puzzle  -->  25! ~ 1025 states
open list:
4 6
nextEval = INFINITY;
 only try the possibilities that you think (based on your
currentNode = startNode;
 generate and search all possibilities (but inefficient)
 starting state
 h(goal) = 0
4. open = [K-E L-E F-B C-A D-A]  closed = [E B A]
from the initial state to the goal
 h3: Even Better
29
Slide 18
Slide 5
on a plateau
 …
Heuristic - Heureka!
Best-First: Example
4. Path cost function
But no one ever won the prize…
  h1(n) = Hamming distance = number of misplaced tiles = 6
some function
 Depth-first:
60
h(n) = 1
 Always choose the next node to visit to be the one with the
 h3(n) = sum of permutation inversions
50
to a node s’ if
 Solution:
but there is a good chance of finding it quickly
 problem with hill-climbing:
3. open = [C-A D-A  E-B F-B]  closed = [B A]
termination
Motivation
state matches the goal state
Iterative Deepening: Example
16
 Insert nodes in open list so that the nodes are sorted in
46
 reached a local maximum, not the global maximum
68
each movement costs 1
Slide 50
 Uniform-cost
 Not optimal (no guarantee to find the shortest path)
65
from s to so
(tiles out of place)
STATE n
Assume U is goal state
COMP 6721: State Space Search
79
 ex: TSP: "nearest neighbour" heuristic
 Maintain depth/cost count, i.e., give preference to
3 4
 Breadth-first:
re
Slide 1
there are several standard goals states for the 8-puzzle
 Breadth-first
b) Else, take the first node s  from the open list.
1 2 3
Slide 49
Snapshot of BFS
11
 g(n) current cost from start to node n
robotics.stanford.edu/~latombe/cs121/2003/home.htm
Steepest Ascent Hill Climbing
currentNode = nextNode;
 For two admissible heuristics h1 and h2
 h3(n) = n5 + n8 + n4 + n2 + n1 + n7 + n3 + n6
loop do
31
59
 g(n) = cost of current path from start to node n
 so far, all search algorithms have been uninformed (general
Uninformed VS Informed Search
Google itinerary
 8-puzzle --> 0.036 sec
58
they are not already in the closed and/or open lists (to avoid
 If you have a good h(n), best-first can find the
 uses a priority queue sorted using
74
the root
43
nextNode = c;
3
 Determine order for examining states
the
 visit successors before siblings
 nodes are added at the end of the list.
inversions
Snapshot of DFS
the better the search performance
 guarantees to find the lowest cost solution path to the
 1075 = nb of molecules in the universe
Search
rep.Planning
 h(n) estimate of the lowest cost from n to goal
 Open is a priority queue sorted using the depth of the nodes from
Admissibility
 e.g. state space of all possible moves in chess = 10120
 Each state is
 Modified evaluation function f:
 Failure (no solution)
from the initial state by any sequence of action
current one, select it.
Example: 8-Puzzle – Heuristic 2
 Heuristic:
Search Uses h(n)? Open is a…
Initial state Goal state
Slide 2
 Summary
 the best result is then chosen.
62
a lower h(n) is better…
→ Worksheet #1 (“Algorithm A”)
 but could lead to infinite loop
 Foothills (or local maxima)
 measure for the “quality” of a heuristic
→ Worksheet #1 (“Depth-First Search”)
 Now consider f*(n) = g*(n) + h*(n):
 An admissible heuristics may temporarily reach non-goal states
 Uninformed search
Knowledge
 ex: 8-puzzle: we may need to move tiles temporarily out of goal
Slide 80
have the same value.
Slide 22
Depth = length of path from root to node
Depth-Limited Search
Slide 68
Designing Heuristics
- guarantees to find the lowest
Uniform Cost No Priority queue sorted by g(n)
g(n), h(n) and f(n)
Slide 44
g(n)
 ex. solved puzzle, being at Concordia
highlighted

3. open = [E-B F-B C-A D-A]  closed = [B A]
14
Artificial Intelligence:
Adapted from https://en.wikipedia.org/wiki/Hill_climbing
Slide 71
search space is too large
 one move is selected and all others are forgotten.
 works well on a "shoulder"
 Intuition: number of misplaced tiles is less informed than
source: adapted from G. Luger (2005)
terminate
 We try to choose smartly
Slide 73
8
= 16
 ex. unsolved puzzle, being at home
Compromise between BFS and DFS:
 BFS: (open is a queue)
 guarantees to find the lowest cost path to each state n
44
number of tiles out of place
 h1: Simplest heuristic
 sum of permutation
 General hill climbing strategy:
Slide 47
 h*(n) actual lowest cost from n to goal
 Iterative deepening search
Example: 8-Puzzle – Heuristic 3
Slide 23
n goal
 Heuristic evaluation functions are highly
 An arc (or edge)
current node
Best-First Search
5 6
  Many slides from:
Slide 59
Slide 58
source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991.
Initial state
is better than the current one
Slide 20
 “local admissibility”
Data Structures
 15-puzzle --> ~ 55 hours
Manhattan distance
Notes on Best-first
source: Russel & Norvig (2003)
 In all search strategies, you need:
 Iterative Deepening
 Heuristic function h(n) = an approximation of the
Slide 45
 pickup&putOnTable(Block)
= 13
search
Open = [F, G, H, I, J, K, L]
15-puzzle
State Space Search
pickup&stack(A,H) pickup&putOnTable(H)
position in order to place another tile in goal position
 So how do we design a “good” heuristic?
State Space
88
 See next slide…
 State Space Representation
3. Repeat
  DFS uses a stack:
 A heuristic is monotonic if it always finds the optimal path to
4 5 6
3. open = [C-A-4 E-B-5 F-B-5  D-A-6]  closed = [B A]
 Uniform Cost
ter
cycles)
 use depth-first search, but
source: G. Luger (2005)
Iterative Deepening No Stack
= n5 + n8 + n4  + n2 + n1 + n7 + n3 + n6
Monotonicity (aka consistent)
70
 Informed search
represented by a
return currentNode;
23
 Search graph at
Slide 8
 A*
 Operators:
 Problem is represented by:
Depth-first No Stack
 It is an exhaustive search …
Slide 55
 For each numbered tile, count how many tiles on its right
in the search
 ex:
38
54
depth-first
pickup&putOnTable(A)
 Need an evaluation function (heuristic function) to
 a rule of thumb, a good bet
Closed = [A, B, C, D, E]
 if h1(n) ≤ h2(n), for all states n
Today
source: Rich & Knight, Artificial Intelligence, McGraw-Hill College 1991. & Russel & Norvig (2003)
73
 Preferred search method when there is a large search
 but has no guarantee to be correct whatsoever!
Search tree
 A heuristic is admissible if it never overestimates the
....
 Bidirectional search
Slide 48
 Breadth First Search
 guarantees to find the lowest cost path to each state n encountered
http://robotics.stanford.edu/~latombe/cs121/winter02/home.htm
L = CHILDREN(currentNode);
a) If the open list  is empty, then exit with failure.
the search, each node in the lists contain:
Yes Priority queue sorted by f(n)
State Graph
dependent on the search domain
 States on open
 8-puzzle  -->  9! = 362,880 states
4. → Worksheet #1 (“Breadth-First Search”)
27
 Cutoff (no solution within cutoff)
Example: 8-Puzzle – Heuristic 1
connects a node s
LeftUpRight
72
evaluating the heuristic…
 i.e. it guarantees to find the lowest cost solution path
1. open = [A-null-5]  closed = []
53
Best-First Search: Example
node n
Slide 6
Slide 67
 24-puzzle  -->  > 109 years
85
83
Slide 42
Breadth-First Search Example
49
 Finds the shortest path (limited depth)
 the more informed, the better
Example: 8-Puzzle
ascending  h(n)
 Random-restart hill-climbing
 Steepest ascent hill climbing:
encountered in the search
Slide 84
 i.e. h(n) never overestimates the true cost from n to a goal
2. Heuristic search:
Natural
Compromise for DFS :
... Expert
 But: heuristic might fail
 However, you need to consider the computational cost of
5Depth
= 4  + 6  + 3   + 1   + 0  + 2  + 0  + 0  = 16
 Nb of states:
Some parameter to represent n
Slide 41
 f(n) estimate of total cost along path through n
 Optimal: will always finds shortest path
 so lower h(n) is better
57
 The time spent computing heuristics must be recovered
goal (if it exists)
 but we can list the possibilities and search through them
score a node in the search tree
Example: The 8-puzzle
Slide 3
5Path-Cost
strategy
 Uniform Cost Search
 In graph representation, cycles can prevent
 nodes are added on the top of the list.
so the path cost is the length of the path (the number of moves)
 with a maximum depth before going to next level
t n
 Hamming distance : count
 Depth-limited Search
63
 Most of the time, it is not feasible to do an exhaustive search,
24
34
than some other states farther away.
 h1(n)  = 6
d) Else, insert s in the closed list (s has been visited /expanded)
but never go back…
20
76
 open list (aka the frontier)
 h1(n)  = misplaced numbered tiles
= 6
Slide 14
 But both search are impractical in real applications
 this is called best-first search
DFS and BFS
Slide 60
Slide 76
35
Slide 85
Depth-first vs. Breadth-first
 Does not maintain a list of next nodes to visit (an open list)
9
--> admissible
hill-climbing will stop,
Slide 70
- no constraints on h(n)
Breadth-first vs Depth-first Search
Slide 26
 never overestimates the actual cost of reaching the goal
33
 best-first used with such a g(n) is called “algorithm A”
 i.e.:
47
 will eventually try all possible paths
h(n)
Slide 13
